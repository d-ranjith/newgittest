const axios = require('axios');
const Logger = require('../config/logger');

class ServiceController {
  static async uploadService(serviceData, endpoint, token) {
    try {
      const response = await axios.post(endpoint, serviceData, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });

      Logger.log('Service data uploaded successfully');
      Logger.log('Response:', JSON.stringify(response.data));

      if (response.status === 200) {
        return { success: true, status: response.status };
      } else {
        return { success: false, status: response.status };
      }
    } catch (error) {
      Logger.error('Service upload error:', error.message);

      if (error.response) {
        Logger.error('Response status:', error.response.status);
        Logger.error('Response data:', JSON.stringify(error.response.data));
        return { success: false, status: error.response.status };
      } else {
        return { success: false, status: 500 }; // Internal Server Error
      }
    }
  }
}

module.exports = ServiceController;



  const uploadResponse = await ServiceController.uploadService(serviceData, API_ENDPOINT, token);

  if (uploadResponse.success) {
    Logger.log('Service data upload successful');
    Logger.log('HTTP Status Code:', uploadResponse.status);
  } else {
    Logger.error('Service data upload failed');
    Logger.error('HTTP Status Code:', uploadResponse.status);
  }




const fileURL = 'https://your-artifactory-url.com/path/to/file';
const destinationPath = 'path/to/destination/file';

downloadFile(fileURL, destinationPath)
  .then(() => {
    console.log('File downloaded successfully');
  })
  .catch((error) => {
    console.error('Error downloading file:', error.message);
  });




your-app/
  |- src/
  |   |- config/
  |   |    |- logger.js
  |   |    |- schema.js
  |   |
  |   |- controllers/
  |   |    |- FileController.js
  |   |    |- OAuthController.js
  |   |    |- ServiceController.js
  |   |
  |   |- models/
  |   |    |- Service.js
  |   |
  |   |- utils/
  |   |    |- FileHandler.js
  |   |    |- Logger.js
  |   |
  |   |- app.js
  |
  |- tests/
  |   |- FileController.test.js
  |   |- OAuthController.test.js
  |   |- ServiceController.test.js
  |
  |- .env
  |- Dockerfile
  |- package.json
  |- README.md

Here are the contents of the code files based on the provided folder structure:

logger.js (src/config/logger.js):
javascript
Copy code
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, printf } = format;

const logFormat = printf(({ level, message, timestamp }) => {
  return `${timestamp} [${level.toUpperCase()}] - ${message}`;
});

const logger = createLogger({
  format: combine(timestamp(), logFormat),
  transports: [new transports.Console()],
});

module.exports = logger;
schema.js (src/config/schema.js):
javascript
Copy code
const Joi = require('joi');

const schema = Joi.object({
  CREDENTIALS_FILE_PATH: Joi.string().required(),
  ARCHIVE_TYPE: Joi.string().valid('tar.gz', 'zip').required(),
  ARTIFACTORY_URL: Joi.string().uri().required(),
  API_ENDPOINT: Joi.string().uri().required(),
  DEBUG: Joi.string().valid('true', 'false').required(),
});

module.exports = schema;
FileController.js (src/controllers/FileController.js):
javascript
Copy code
const fs = require('fs');
const Logger = require('../config/logger');

class FileController {
  static readCredentialsFromFile(filePath) {
    try {
      const fileData = fs.readFileSync(filePath, 'utf8');
      const { client_id, client_secret } = JSON.parse(fileData);
      Logger.debug(`Credentials: ${process.env.DEBUG ? JSON.stringify({ client_id, client_secret }) : '********'}`);
      return { client_id, client_secret };
    } catch (error) {
      Logger.error(`Error reading credentials from file: ${error.message}`);
      return null;
    }
  }
}

module.exports = FileController;
OAuthController.js (src/controllers/OAuthController.js):
javascript
Copy code
const jwt = require('jsonwebtoken');
const Logger = require('../config/logger');

class OAuthController {
  constructor(client_id, client_secret) {
    this.client_id = client_id;
    this.client_secret = client_secret;
  }

  fetchToken() {
    return new Promise((resolve) => {
      setTimeout(() => {
        const dummyToken = jwt.sign({ username: 'example_user' }, 'dummy_secret');
        Logger.log('Token fetched successfully');
        Logger.debug(`Token: ${process.env.DEBUG ? dummyToken : '********'}`);
        resolve(dummyToken);
      }, 2000);
    });
  }

  validateToken(token) {
    return new Promise((resolve) => {
      setTimeout(() => {
        try {
          const decodedToken = jwt.verify(token, 'dummy_secret');
          Logger.log('Token validated successfully');
          resolve(true);
        } catch (error) {
          Logger.error(`Token validation error: ${error.message}`);
          resolve(false);
        }
      }, 1000);
    });
  }
}

module.exports = OAuthController;
ServiceController.js (src/controllers/ServiceController.js):
javascript
Copy code
const fs = require('fs');
const request = require('request-promise-native');
const Logger = require('../config/logger');

class ServiceController {
  static async uploadService(serviceData, endpoint) {
    try {
      const options = {
        method: 'POST',
        uri: endpoint,
        headers: {
          'Content-Type': 'application/json',
        },
        body: serviceData,
        resolveWithFullResponse: true,
        json: true,
      };

      const response = await request(options);

      Logger.log(`Upload Response: ${JSON.stringify(response.body)}`);
      Logger.log(`HTTP Status Code: ${response.statusCode}`);
      return response.statusCode;
    } catch (error) {
      Logger.error(`Service upload error: ${error.message}`);
      throw error;
    }
  }
}

module.exports = ServiceController;

Here are the remaining code files based on the provided folder structure:

Service.js (src/models/Service.js):
javascript
Copy code
class Service {
  static async extractTarGz(source, destination) {
    // Implementation for extracting tar.gz archives
  }

  static async extractZip(source, destination) {
    // Implementation for extracting zip archives
  }
}

module.exports = Service;
FileHandler.js (src/utils/FileHandler.js):
javascript
Copy code
const fs = require('fs');
const Logger = require('../config/logger');

class FileHandler {
  static readCredentialsFromFile(filePath) {
    try {
      const fileData = fs.readFileSync(filePath, 'utf8');
      const { client_id, client_secret } = JSON.parse(fileData);
      Logger.debug(`Credentials: ${process.env.DEBUG ? JSON.stringify({ client_id, client_secret }) : '********'}`);
      return { client_id, client_secret };
    } catch (error) {
      Logger.error(`Error reading credentials from file: ${error.message}`);
      return null;
    }
  }
}

module.exports = FileHandler;
app.js (src/app.js):
javascript
Copy code
const fs = require('fs');
const request = require('request');
const jwt = require('jsonwebtoken');
const dotenv = require('dotenv');
const { promisify } = require('util');
const { extractTarGz, extractZip } = require('./models/Service');
const FileHandler = require('./utils/FileHandler');
const Logger = require('./config/logger');
const SchemaValidator = require('./config/schema');
const { uploadService } = require('./controllers/ServiceController');
const { fetchToken, validateToken } = require('./controllers/OAuthController');

dotenv.config();

class Application {
  constructor(credentialsFilePath, archiveType, artifactoryURL, apiEndpoint) {
    this.credentialsFilePath = credentialsFilePath;
    this.archiveType = archiveType;
    this.artifactoryURL = artifactoryURL;
    this.apiEndpoint = apiEndpoint;
  }

  async run() {
    const { client_id, client_secret } = FileHandler.readCredentialsFromFile(this.credentialsFilePath);
    if (!client_id || !client_secret) {
      Logger.error('Invalid credentials');
      return;
    }

    try {
      await this.downloadFile(this.artifactoryURL, 'downloaded_file');
      const token = await fetchToken(client_id, client_secret);
      const isValidToken = await validateToken(token);
      if (isValidToken) {
        const serviceData = fs.readFileSync('service_data.json', 'utf8');
        const uploadResponse = await uploadService(serviceData, this.apiEndpoint);
        Logger.log(`Upload Response: ${JSON.stringify(uploadResponse)}`);
      } else {
        Logger.error('Invalid token');
      }
    } catch (error) {
      Logger.error(`Error running the application: ${error.message}`);
    }
  }

  async downloadFile(url, destination) {
    return new Promise((resolve, reject) => {
      const fileStream = fs.createWriteStream(`${destination}.${this.archiveType}`);
      request(url)
        .on('response', (response) => {
          Logger.debug(`Download File Size: ${process.env.DEBUG ? response.headers['content-length'] : '********'}`);
        })
        .pipe(fileStream)
        .on('finish', async () => {
          Logger.log('File downloaded successfully');
          await this.extractFile(`${destination}.${this.archiveType}`, destination);
          resolve();
        })
        .on('error', (error) => {
          Logger.error(`Error downloading file: ${error.message}`);
          reject(error);
        });
    });
  }

  async extractFile(source, destination) {
    switch (this.archiveType) {
      case 'tar.gz':
        await Service.extractTarGz(source, destination);
        break;
      case 'zip':
        await Service.extractZip(source, destination);
        break;
      default:
        Logger.error(`Unsupported archive type: ${this.archiveType}`);
        break;
    }
  }
}

const envVars = SchemaValidator.validate(process.env);

const app = new Application(
  envVars.CREDENTIALS_FILE_PATH,
  envVars.ARCHIVE_TYPE,
  envVars.ARTIFACTORY_URL,
  envVars.API_ENDPOINT
);
app.run();



---- unit tests
FileController.test.js (tests/FileController.test.js):

const fs = require('fs');
const FileController = require('../src/controllers/FileController');

describe('FileController', () => {
  describe('readCredentialsFromFile', () => {
    it('should read credentials from file and return an object', () => {
      // Set up
      const filePath = 'test/credentials.json';
      const expectedCredentials = {
        client_id: 'your-client-id',
        client_secret: 'your-client-secret',
      };

      // Mock the fs.readFileSync method
      jest.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify(expectedCredentials));

      // Call the method being tested
      const credentials = FileController.readCredentialsFromFile(filePath);

      // Assertions
      expect(credentials).toEqual(expectedCredentials);

      // Restore the original method
      fs.readFileSync.mockRestore();
    });

    it('should handle errors when reading credentials from file', () => {
      // Set up
      const filePath = 'test/non-existent-file.json';

      // Mock the fs.readFileSync method to throw an error
      jest.spyOn(fs, 'readFileSync').mockImplementation(() => {
        throw new Error('File not found');
      });

      // Call the method being tested
      const credentials = FileController.readCredentialsFromFile(filePath);

      // Assertions
      expect(credentials).toBeNull();

      // Restore the original method
      fs.readFileSync.mockRestore();
    });
  });
});


Copy code
// Unit tests for FileController.js
const jwt = require('jsonwebtoken');
const OAuthController = require('../src/controllers/OAuthController');

jest.mock('jsonwebtoken');

describe('OAuthController', () => {
  describe('fetchToken', () => {
    it('should fetch a token successfully', async () => {
      // Set up
      const expectedToken = 'your-token';
      const client_id = 'your-client-id';
      const client_secret = 'your-client-secret';

      // Mock the jwt.sign method
      jwt.sign.mockReturnValue(expectedToken);

      // Create an instance of the OAuthController
      const oauthController = new OAuthController(client_id, client_secret);

      // Call the method being tested
      const token = await oauthController.fetchToken();

      // Assertions
      expect(token).toBe(expectedToken);

      // Verify that jwt.sign was called with the correct arguments
      expect(jwt.sign).toHaveBeenCalledWith({ username: 'example_user' }, client_secret);

      // Restore the original method
      jwt.sign.mockRestore();
    });
  });

  describe('validateToken', () => {
    it('should validate a valid token', async () => {
      // Set up
      const token = 'valid-token';
      const client_id = 'your-client-id';
      const client_secret = 'your-client-secret';

      // Mock the jwt.verify method
      jwt.verify.mockReturnValue(true);

      // Create an instance of the OAuthController
      const oauthController = new OAuthController(client_id, client_secret);

      // Call the method being tested
      const isValidToken = await oauthController.validateToken(token);

      // Assertions
      expect(isValidToken).toBe(true);

      // Verify that jwt.verify was called with the correct arguments
      expect(jwt.verify).toHaveBeenCalledWith(token, client_secret);

      // Restore the original method
      jwt.verify.mockRestore();
    });

    it('should handle an invalid token', async () => {
      // Set up
      const token = 'invalid-token';
      const client_id = 'your-client-id';
      const client_secret = 'your-client-secret';

      // Mock the jwt.verify method to throw an error
      jwt.verify.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      // Create an instance of the OAuthController
      const oauthController = new OAuthController(client_id, client_secret);

      // Call the method being tested
      const isValidToken = await oauthController.validateToken(token);

      // Assertions
      expect(isValidToken).toBe(false);

      // Verify that jwt.verify was called with the correct arguments
      expect(jwt.verify).toHaveBeenCalledWith(token, client_secret);

      // Restore the original method
      jwt.verify.mockRestore();
    });
  });
});



javascript

ServiceController.test.js (tests/ServiceController.test.js):


const ServiceController = require('../src/controllers/ServiceController');
const Service = require('../src/models/Service');

jest.mock('../src/models/Service');

describe('ServiceController', () => {
  describe('uploadService', () => {
    it('should upload a service successfully', async () => {
      // Set up
      const serviceData = 'your-service-data';
      const endpoint = 'your-api-endpoint';
      const statusCode = 200;

      // Mock the Service model's static method
      Service.uploadService.mockResolvedValue(statusCode);

      // Create an instance of the ServiceController
      const serviceController = new ServiceController();

      // Call the method being tested
      const response = await serviceController.uploadService(serviceData, endpoint);

      // Assertions
      expect(response).toBe(statusCode);

      // Verify that Service.uploadService was called with the correct arguments
      expect(Service.uploadService).toHaveBeenCalledWith(serviceData, endpoint);

      // Restore the original method
      Service.uploadService.mockRestore();
    });

    it('should handle a service upload error', async () => {
      // Set up
      const serviceData = 'your-service-data';
      const endpoint = 'your-api-endpoint';
      const errorMessage = 'Service upload failed';

      // Mock the Service model's static method to throw an error
      Service.uploadService.mockRejectedValue(new Error(errorMessage));

      // Create an instance of the ServiceController
      const serviceController = new ServiceController();

      // Call the method being tested
      try {
        await serviceController.uploadService(serviceData, endpoint);
      } catch (error) {
        // Assertion
        expect(error.message).toBe(errorMessage);
      }

      // Verify that Service.uploadService was called with the correct arguments
      expect(Service.uploadService).toHaveBeenCalledWith(serviceData, endpoint);

      // Restore the original method
      Service.uploadService.mockRestore();
    });
  });
});


==== dockerfile

# Use an official Node.js runtime as the base image
FROM node:14

# Set the working directory in the container
WORKDIR /app

# Copy the package.json and package-lock.json files to the container
COPY package.json package-lock.json ./

# Install the application dependencies
RUN npm install --production

# Copy the application source code to the container
COPY src ./src
COPY tests ./tests

# Expose a port for the application (if needed)
# EXPOSE 3000

# Set the environment variables (if needed)
# ENV NODE_ENV=production

# Run the command to start the application
CMD ["npm", "start"]


--- package.json

{
  "name": "your-app",
  "version": "1.0.0",
  "description": "Your application description",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "test": "jest"
  },
  "keywords": [],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "express": "^4.17.1",
    "joi": "^17.4.2",
    "jsonwebtoken": "^8.5.1",
    "request": "^2.88.2",
    "request-promise-native": "^1.0.9",
    "tar": "^6.1.0",
    "unzipper": "^0.10.11"
  },
  "devDependencies": {
    "jest": "^27.0.6",
    "supertest": "^6.1.6"
  }
}











